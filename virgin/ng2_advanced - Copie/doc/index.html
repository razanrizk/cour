<!doctype html><html lang="en"><head><meta charset="utf-8"><title>Angular</title><link rel="stylesheet" href="style.css" media="all" type="text/css" /></head><body><div class="container"><!-- section --><div class="section">	<h2 class="section_title">Développement JavaScript : rappels</h2></div><!-- section --><!-- page --><div class="page">	<h2 class="page_title">Bonnes pratiques Ecmascript 5</h2>	<div class="page_content"><p>Javascript est un langage qui évolue en permanence, ceci dit, dans sa version Ecmascript 5, les bonnes pratiques restent globalement inchangées. Les voici en versions condensées, et bien entendu cette liste n'est en rien exhaustive.</p><ul class="page_list"><li>Eviter les variables globales</li><li>Déclarer les variables locales à l'aide du mot clé "var"</li><li>Le mode strict doit être utilisé</li><li>Eviter la fonction eval()</li><li>Organiser son code en module</li><li>Une expression doit toujours se terminer par un point-virgule</li><li>Le code doit être découpé en plusieurs fichiers</li></ul><p>... Et bien d'autres que vous pourrez retrouver par exemple à l'adresse suivante : https://maxlab.fr/javascript/bonnes-pratiques-javascript-pour-lentreprise</p></div>	<p class="pagination">2/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">ES7/ES6/ES2015, présentation générale.</h2>	<div class="page_content"><p>ECMAScript est un ensemble de normes concernant les langages de programmation de type script et standardisées par Ecma International dans le cadre de la spécification ECMA-262. Il s'agit donc d'un standard, dont les spécifications sont mises en œuvre dans différents langages de script, comme JavaScript ou ActionScript, ainsi qu'en C++ (norme 2011). C'est un langage de programmation orienté prototype.</p><p>Pour le langage Javascript, la norme ECMASCRIPT 5 est aujourd'hui la plus répandue, toutefois certains navigateurs, comme Chrome (Google Inc.), mettent déjà à disposition des développeurs une implémentation de Javascript respectant la norme ECMA 6 (ES2015).</p><p>Nommée ES2015, la dernière version d'ECMAScript a été publiée en juin 20156. Son support par les navigateurs évolue progressivement, mais il est possible d'utiliser un transcompilateur (tel que Babel.js8) vers ES5 pour développer dès aujourd'hui en ES6.</p><p>Première version publiée après le changement du processus de normalisation, l'ES7, ou ES2016, apporte peu de changements au langage. Le nouveau processus prévoit en effet de publier chaque année une nouvelle norme avec les ajouts qui ont eu lieu dans l'intervalle, afin d'éviter de publier des changements énormes comme ce fut le cas en 20159.</p></div>	<p class="pagination">3/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">ECMASCRIPT 6 et 7, les nouveautés</h2>	<div class="page_content"><p>Les normes ECMASCRIPT 6 et 7 arrivent avec leurs lots de nouvelles fonctionnalités notamment les suivants ( mais pas que ): </p><ul class="page_list"><li>Les mot-clés let et const</li><li>Les templates et chaînes de caractères</li><li>Les paramètres par défaut</li><li>Les promesses</li><li>Les fonctions lambda ( arrow functions )</li><li>Les classes et l'héritage</li></ul><p>Nous allons détailler un peu plus chacune de ces fonctionnalités.</p></div>	<p class="pagination">4/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Les mot-clés let et const</h2>	<div class="page_content"><p>Le mot clé <strong>let</strong> permet de déclarer une variable limitée à la portée d'un bloc, c'est-à-dire qu'elle ne peut être utilisée que dans le bloc où elle a été déclarée, ce qui n'est pas le cas avec var.</p><p>Le mot-clé  <strong>const</strong> sert à définir une valeur immuable, accessible uniquement en lecture seule.</p><p class="legend">let_const.js</p><code><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">whoIsTheSithLord</span>(<span class="hljs-params">p_padawan</span>) 
</span>{
    <span class="hljs-keyword">var</span> sith_lord = <span class="hljs-string">"Palpatine"</span>;

    <span class="hljs-keyword">if</span> (p_padawan === <span class="hljs-literal">true</span> ) 
    {
        <span class="hljs-keyword">let</span> padawan = <span class="hljs-string">"Dark Vador"</span>;
    }

    <span class="hljs-built_in">console</span>.log(sith_lord); <span class="hljs-comment">// displays Palpatine</span>
    <span class="hljs-built_in">console</span>.log(padawan); <span class="hljs-comment">// undefined</span>

    <span class="hljs-comment">//la variable padawan existe uniquement dans le bloc conditionnel, </span>
    <span class="hljs-comment">// à l'inverse de sith_lord.</span>
}

whoIsTheSithLord(<span class="hljs-literal">true</span>);</pre></code></div>	<p class="pagination">5/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Templates Strings</h2>	<div class="page_content"><p>Les "templates strings" permettent d'insérer plus facilement des valeurs de variables au sein d'une chaîne de caractère, ces dernières peuvent également être définies sur plusieurs lignes.</p><p class="legend">template_string.js</p><code><pre><span class="hljs-keyword">let</span> jedi = {<span class="hljs-attr">surname</span>:<span class="hljs-string">"Obiwan"</span>, <span class="hljs-attr">name</span>:<span class="hljs-string">"Kenobi"</span>}; 
<span class="hljs-keyword">let</span> msg = <span class="hljs-string">`<span class="hljs-subst">${jedi.name}</span> <span class="hljs-subst">${jedi.surname}</span> is the Jedi Master`</span>;
<span class="hljs-built_in">console</span>.log(msg);</pre></code></div>	<p class="pagination">6/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Paramètres par défaut</h2>	<div class="page_content"><p>Il est dorénavant possible de donner une valeur par défaut aux paramètres, cela évite les lignes de codes superflues et facilite la lecture du code.</p><p class="legend">default_params.js</p><code><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">whoIsTheSithLord</span>(<span class="hljs-params">p_name=<span class="hljs-string">'Dark Vador'</span></span>)
</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"The Sith lord is: "</span>, p_name);
}

whoIsTheSithLord();</pre></code></div>	<p class="pagination">7/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Les fonctions fléchées/lambdas</h2>	<div class="page_content"><p>Il s'agit d'une nouvelle façon d'écrire les fonctions anonymes, plus compacte et permettant de lier définitivement le contexte d'éxécution de la fonction (this).</p><p class="legend">lambda_functions.js</p><code><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">launchFunc</span>(<span class="hljs-params">p_function</span>) </span>{
    p_function();
}

<span class="hljs-comment">// ecma 5 style anonymous function</span>
launchFunc(
    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"I am The Sith Lord"</span>)
    }
);

<span class="hljs-comment">// ecma6 arrow function</span>
launchFunc(
    <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"I am The Sith Lord"</span>) }
);</pre></code></div>	<p class="pagination">8/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Les promesses</h2>	<div class="page_content"><p>L'objet Promise (pour « promesse ») est utilisé pour réaliser des traitements de façon asynchrone. Une promesse représente une valeur qui peut être disponible maintenant, dans le futur voire jamais.</p><p>L'interface Promise représente un intermédiaire (proxy) vers une valeur qui n'est pas nécessairement connue au moment de sa création. Cela permet d'associer des gestionnaires au succès éventuel d'une action asynchrone et à la raison d'une erreur. Ainsi, des méthodes asynchrones renvoient des valeurs comme les méthodes synchrones, la seule différence est que la valeur retournée par la méthode asynchrone est une promesse (d'avoir une valeur plus tard).</p><p class="legend">promises.js</p><code><pre><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XmlHttpRequest();
    xhr.open(<span class="hljs-string">"GET"</span>, url);
    xhr.onload = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(xhr.responseText);
    xhr.onerror = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> reject(xhr.statusText);
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">p_msg</span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"resolve: "</span>, p_msg);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">p_msg</span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"reject: "</span>, p_msg);
}</pre></code></div>	<p class="pagination">9/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Classes et Héritages</h2>	<div class="page_content"><p>Ecma 6 introduit des mécanismes Orienté Objet par classe grâce aux mots-clés <strong>class</strong> et <strong>extends</strong>, malheureusement ces derniers n'introduisent aucun changement dans la manière dont les objets sont réellements agencés et conçus au sein de la VM Javascript, il s'agit uniquement de sucre syntaxique.</p><p class="legend">es6_class.js</p><code><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Personnage</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
        <span class="hljs-keyword">this</span>.name = <span class="hljs-string">""</span>;
    }

    sayMyName() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name);
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JediKnight</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Personnage</span> </span>{
    <span class="hljs-keyword">constructor</span>(p_name) {
        <span class="hljs-keyword">this</span>.power = <span class="hljs-number">250</span>;
        <span class="hljs-keyword">this</span>.name = p_name;
    }
}

<span class="hljs-keyword">let</span> obiwan = <span class="hljs-keyword">new</span> JediKnight(<span class="hljs-string">"Obiwan Kenobi"</span>);
obiwan.sayMyName();</pre></code></div>	<p class="pagination">10/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Les Observables</h2>	<div class="page_content"><p>Un Observable est un producteur de données qui peut être observé. On le mettra sous observation avec la méthode <strong>subscribe</strong> et cette observation sera exécutée par un objet de type Observer. Les Observables se sont imposés dans le monde de la programmation réactive ( reactive programming ) par le biais de la librairie Reactive X, abrégé RxJs pour sa version Javascript. Un Observable peut également produire des données de façon asynchrone et il est possible de fusionner plusieurs Observables entre eux.</p><p>Il faut bien noter que les Observables sont souvent associés aux promesses, voire décrits comme des super-promesses, ce qui n'est pas tout à fait exact, un article entier a d'ailleurs été rédigé à l'attention des développeurs à l'adresse suivante: https://medium.com/@benlesh/learning-observable-by-building-observable-d5da57405d87 et explique un peu plus en détail ce que sont les Observables.</p><p class="legend">observables.js</p><code><pre>Rx.Observable.create(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">observer</span>) </span>{
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> observer.next(<span class="hljs-string">"valeur A"</span>), <span class="hljs-number">700</span>);
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> observer.next(<span class="hljs-string">"valeur B"</span>), <span class="hljs-number">400</span>);
})
 .subscribe(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(e));

 <span class="hljs-comment">// affiche "valeur A", puis "valeur B"  dans la console</span></pre></code></div>	<p class="pagination">11/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Reactive Extension For Javascript (RxJS)</h2>	<div class="page_content"><p>Reactive Extensions (Rx) est une bilbiothèque permettant de développer des applications "orientées évènements" et utilisant des requêtes asynchrones en liant entre elles des séquences d'objets de type Observables.</p><p>Les séquences de données peuvent prendre plusieurs formes, telle qu'un flux de données issue d'un webservice, des requêtes vers des webservices, des notifications systèmes, ou bien encore une séquence d'évènements utilisateurs etc...</p><p>Rx represente toutes ces données sous la forme d'une séquence d'Observables, une application peut souscrire à ce flux de données et être notifiée chaque fois qu'une donnée est ajoutée au flux.</p><p>La comparaison avec les promesses est alors tentante et il est possible de se faire une idée plus précise de ce que sont les Observables et dans quels domaine les préférer par rapport aux Promises à l'adresse suivante: https://xgrommx.github.io/rx-book/index.html</p></div>	<p class="pagination">12/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Les outils</h2>	<div class="page_content"><p>L'une des choses les plus difficiles à déterminer lorsque l'on commence un développement en Angular 2 est la stack complète de développement. Fort heureusement, une multitude d'outils tous plus performants les uns que les autres sont venus renforcer l'écocsystème Javascript ces derniers temps, et ce, grâce à <strong>node.js</strong> et son gestionnaire de dépendances spécialisé front-end <strong>npm</strong>. L'on peut donc compter au rang des outils quasiment indispensables: </p><ul class="page_list"><li>Node.Js et NPM (node package manager)</li><li>Typescript ( langage poussé par Google pour le développement Angular 2 )</li><li>Un bon éditeur Typescript (Micorsoft Visual Code)</li><li>Un outil de scaffolding ( génération de structure de projets et codes ) comme @angular/cli</li><li>Un module loader, comme Webpack</li><li>Un bon navigateur et/ou environnement d'éxécution ( Google Chrome, Ionic ... )</li></ul></div>	<p class="pagination">13/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Le langage Typescript</h2>	<div class="page_content"><p>TypeScript est un langage de programmation libre et open source développé par Microsoft qui a pour but d'améliorer et de sécuriser la production de code JavaScript. C'est un sur-ensemble de JavaScript (c'est-à-dire que tout code JavaScript correct peut être utilisé avec TypeScript). Le code TypeScript est transcompilé en JavaScript, pouvant ainsi être interprété par n'importe quel navigateur web ou moteur JavaScript.</p><p>TypeScript permet un typage statique optionnel des variables et des fonctions, la création de classes et d'interfaces, l'import de modules, tout en conservant l'approche non-contraignante de JavaScript. Il supporte la spécification ECMAScript 6.</p><ul class="page_list"><li>Typage statique</li><li>Typage générique</li><li>Interfaces</li><li>Classe, classe abstraite, expressions de classe</li><li>Modules</li><li>Mixin</li><li>Enumérations</li><li>Paramètres optionnels</li><li>Symboles</li></ul><p>... Et bien d'autres, d'ailleurs depuis la version 1.6, le format JSX est supporté.</p></div>	<p class="pagination">14/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">ES6 Module Pattern</h2>	<div class="page_content"><p>La norme ES6 prévoit de founir au développeur la possibilité de regrouper et empaqueter des objets, classes, fonctionnalités et valeurs au sein de <strong>modules</strong>, dans la continuité des pattern modulaires déjà bien ancrés au sein de l'écosystème Javascript (AMD par exemple).</p><p>L'instruction export est utilisée pour permettre d'exporter des fonctions et objets ou des valeurs primitives à partir d'un fichier (ou module) donné. Ces fonctions et objets peuvent ensuite être utilisées dans d'autres fichiers grâce à import.</p><p> Cette fonctionnalité n'est pas encore implémentée nativement par la plupart des navigateurs, en revanche, elle est gérée par de nombreux transpileurs comme  <strong>Traceur, Babel ou Rollup.</strong></p><p class="legend">es6_module.js</p><code><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">whoIsTheSithLord</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Palpatine is the Sith Lord !"</span>);
}

<span class="hljs-comment">// on exporte une fonction déclarée plus haut</span>
<span class="hljs-keyword">export</span> { whoIsTheSithLord };

<span class="hljs-comment">// on exporte une constante</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> DARK_VADOR = <span class="hljs-string">"Dark Vador"</span>;</pre></code></div>	<p class="pagination">15/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">ES7 Async functions</h2>	<div class="page_content"><p>La déclaration async function définit une fonction asynchrone qui renvoie un objet AsyncFunction. On peut également définir des fonctions asynchrones grâce au constructeur AsyncFunction et via une expression de fonction asynchrone.</p><p>Lorsqu'une fonction asynchrone est appelée, elle renvoie une promesse. Lorsque la fonction asynchrone renvoie une valeur, la promesse est résolue avec la valeur renvoyée. Lorsque la fonction asynchrone lève une exception, la promesse est rompue avec la valeur de l'exception.</p><p>Une fonction asynchrone peut contenir une expression await qui permet d'interrompre l'exécution de la fonction asynchrone en attendant la résolution d'une promesse passée à l'expression. L'exécution de la fonction asynchrone reprend lorsque la promesse est résolue.</p><p>L'objectif des fonctions asynchrones avec await est de simplifier le comportement des promesses lors d'opérations synchrones et d'opérer sur des groupes de promesses. Si les promesses sont en quelque sorte des callbacks organisés, async/await permet de combiner les générateurs et les promesses. On peut trouver des exemples à l'adresse suivante:  https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/async_function</p></div>	<p class="pagination">16/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Module Loader & Webpack</h2>	<div class="page_content"><p>Un module loader est un outil qui fournit une solution permettant de gérer des modules Javascript, en respectant la norme des ES6 Modules. Il s'agit en règle générale d'une suite logicielle composée d'un utilitaire en ligne de commande et de fichiers à configurer.</p><p>L'un des plus célèbres Module Loader de l'écosystème Javascript est Webpack, ce dernier permet, comme son nom l'indique, de créer des paquetages à partir de fichier Javascript ( mais pas que ) et de les mettre à disposition sous forme de modules au sein d'une application front-end.</p><p>Pour plus de renseignements sur le fonctionnement de Webpack, rendez-vous sur le site officiel du produit à l'adresse suivante: https://webpack.github.io/docs/</p></div>	<p class="pagination">17/89</p></div><!-- page --><!-- section --><div class="section">	<h2 class="section_title">Migrer d'AngularJS 1.x à Angular</h2></div><!-- section --><!-- page --><div class="page">	<h2 class="page_title">Angular 1 VS Angular 2</h2>	<div class="page_content"><p>La version 2 d'Angular introduit bon nombres de modifications structurelles au sein du Framework, voici un petit listing non exhaustif des changements introduits dans la V2.</p><ul class="page_list"><li>L'architecture est maintenant orientée composant</li><li>Il n'y a plus de Controller</li><li>On n'utilise plus ng-app, mais une fonctionnalité de boostrapping</li><li>La mise en avant des Observables</li><li>Simplification de l'écriture des Directives</li><li>Changement de syntaxe pour le bi-directionnal databinding</li><li>Le support et la mise en avant de ES6 et de Typescript</li><li>La plupart des filtres, services, directives inclus dans la v1 sont aujourd'hui disponibles uniquement si on les importe explicitement.</li></ul></div>	<p class="pagination">19/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Principes de l'injection de dépendances</h2>	<div class="page_content"><p>Le principe de l'injection de dépendance est assez simple, dans le cadre d'un développement MVC classique, les fichiers declasses embarquent des références directes aux classes tierces qu'ils utilisent, ce qui le rend le développement lourd à maintenir et empêche le développeur de réutiliser facilement son code. On dit que l'on fait du "monolithic development",dans le sens ou les couches logicielles sont constituées souvent de gros blocs de code.</p><p>L'injection de dépendances quand à elle, permet de déléguer à un objet tiers, la création des objets dont nos modules vontavoir besoin. Cet objet est appelée l'injecteur de dépendance, il va donc se charger de créer les objets demandés etles envoyer aux objets qui en ont besoin. Ainsi ces derniers pourront utiliser des dépendances sans avoir besoin d'avoirune référence directe à ces dernières.</p><p>De plus, cela permet de tester différentes versions de l'application facilement, en effet, puisque les composants ne créentplus eux-mêmes les objets dont ils ont besoin ( souvent des classes gérant des échanges de données par le biais de services), il est possible de demander à l'injecteur de tester une version de l'application avec tel dépendance injectée, puisavec une autre, et ce, en changeant uniquement les élements de configuration.</p><p>Ce pattern s'intègre parfaitement dans le cadre d'une application développée avec des tests d'intégration continue. Parmi les méthodes utilitaires de l'objet angular, la méthode injector nous permet de créer un injecteur de dépendances.</p></div>	<p class="pagination">20/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Directives</h2>	<div class="page_content"><p>Angular 2 intègre comme son prédecesseur des fonctionnalités qui viennent enrichir le framework appelées <strong>Directives</strong>. Ces Directives sont de 2 types: </p><p>- Les Directives structurelles, responsables de la couche HTML, elles modélisent, réorganisent le contenu HTML en ajoutant, supprimant ou en manipulant des élements. On appliquera donc toujours une directive structurelle à un élement HTML Hôte (Host), elle opérera ainsi sur cet hôte et ses descendants. Les directives structurelles sont faciles à reconnaître, dans l'exemple suivant, un astérisque précède la directive:</p><p class="legend">ng2_structural_directives.js</p><code><pre>&lt;div *ngIf=<span class="hljs-string">"hero"</span> &gt;{{hero.name}}&lt;<span class="hljs-regexp">/div&gt;</span></pre></code><p>Il existe également un autre type de Directive, les Directives d'attributs qui permettent entres autres, d'ajouter des comportements à des élements: </p><p class="legend">ng2_attribute_directive.js</p><code><pre><span class="hljs-keyword">import</span> { Directive, ElementRef, Input } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

@Directive({ <span class="hljs-attr">selector</span>: <span class="hljs-string">'[myHighlight]'</span> })
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HighlightDirective</span> </span>{
    <span class="hljs-keyword">constructor</span>(el: ElementRef) {
       el.nativeElement.style.backgroundColor = <span class="hljs-string">'yellow'</span>;
    }
}</pre></code></div>	<p class="pagination">21/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Les decorators</h2>	<div class="page_content"><p>La directive Decorator vous permet de spécifier qu'une classe peut agir comme une directive Angular et procure des méta-données qui détermine la façon dont elle devrait être utilisée, instanciée, et utilisée au sein de l'application.</p><p>Elle permet par exemple de lier une classe à un élement du DOM (selector) et doit appartenir à un module de type NgModule afin de pouvoir être utilisée par d'autres directives, composants ou applications. Pour qu'une directive appartienne à un module, il suffit de la lister au sein du tableau des déclarations dudit module</p><p>En plus des méta-données, il est possible d'implémenter des fonctionnalités prédéfinies qui interviennent dans le cycle de vie des composants et directives. Un composant est une directive possédant un template qui utilise le decorator standard @Component.</p><p class="legend">ng2_decorators.js</p><code><pre>@Component({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'sith'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">"&lt;h1&gt;Dark Vador is The Sith Lord&lt;/h1&gt;"</span>
})
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SithComponent</span></span>{
    
}</pre></code></div>	<p class="pagination">22/89</p></div><!-- page --><!-- section --><div class="section">	<h2 class="section_title">L'utilitaire ng ou @angular/cli</h2></div><!-- section --><!-- page --><div class="page">	<h2 class="page_title">Angular cli</h2>	<div class="page_content"><p>Angular-cli ( pour Angular command line interface ) est un utilitaire en ligne de commande permettant de mettre en place facilement des projets Angular 2, il permet entre autres: </p><ul class="page_list"><li>De créer des structures de projets Angular 2 avec quelques lignes de commandes</li><li>De créer des composants, directives, modules facilement ( scaffolding )</li><li>De mettre en place un environnement de test "end-to-end"</li><li>De maintenir des applications Angular 2</li><li>De monter un serveur de production Angular 2 rapidement</li></ul><p>...Et bien d'autres, et bien entendu l'installation de cet outil est facilitée et passe par le très connu gestionnaire de paquets <strong>npm</strong>, disponible à partir du moment ou node.js est installé sur la machine.</p><p class="legend">ng-cli.sh</p><code><pre><span class="hljs-comment"># exemple de création d'un nouveau projet angular 2 </span>
<span class="hljs-comment"># à l'aide d'Angular-cli</span>

ng new dark-star
<span class="hljs-built_in">cd</span> dark-star
ng serve</pre></code></div>	<p class="pagination">24/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Scaffolding</h2>	<div class="page_content"><p>Il est possible de générer toutes sortes de contenus à l'aide de l'utilitaire ng-cli, par exemple:</p><ul class="page_list"><li>Des classes</li><li>Des components</li><li>Des directives</li><li>Des enums</li><li>Des guards</li><li>Des interfaces</li><li>Des modules</li><li>Des pipes</li><li>Des services</li></ul><p class="legend">ng2_scaffolding.sh</p><code><pre><span class="hljs-comment"># Création d'un composant DarkStarComponent à l'aide de ng-cli</span>

ng generate component DarkStarComponent </pre></code></div>	<p class="pagination">25/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Utilitaires de tâches et environnement</h2>	<div class="page_content"><p>Angular 2 est livré avec de nombreux outils et utilitaires permettant de gérer plusieurs types de tâches. En effet, il est possible de prendre en charge le langage Typescript et ses avantages, puis de le transpiler vers du javascript tout en démarrant un environnement de test bout à bout (end-to-end), et ce, en quelques lignes de commandes ou avec des fichiers de configuration.</p><p>Bien entendu, il existe des techniques plus optimisées que d'autres, notamment la compilation AOT ( Ahead of Time ) que nous verrons plus loin et qui a pour avantage d'augmenter drastiquement les performances d'une application Angular 2 par rapport à une compilée juste à temps (JIT).</p></div>	<p class="pagination">26/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Fichiers de configurations courants</h2>	<div class="page_content"><p>La plupart des environnements Angular 2 se ressemblent, surtout si vous employez des outils de scaffolding tels que ng-cli. Les fichiers contenus dans les répertoires <strong>src/ et e2e/</strong> sont ceux qui importent le plus pour les développeurs car l'on y range le code source de l'application et le code qui gère les test applicatifs.</p><p>La plupart des autres fichiers sont avant tout là pour configurer l'environnement de développement, et chacun d'entre eux répond à une syntaxe bien définie, répondant aux spécifications des produits auxquels ils font référence, c'est d'ailleurs pourquoi nous ne détaillerons pas leur contenu, la documentation officielle étant bien plus adaptée à cet exercice.</p><ul class="page_list"><li><strong>node_modules/</strong>, répertoire contenant les dépendances du projet.</li><li><strong>karma.conf.js</strong> fichier de configuration de Karma</li><li><strong>karma-test-shim.js</strong> fichier de script permettant de lancer Karma</li><li><strong>protractor.config.js</strong> fichier de configuration de protractor</li><li><strong>systemjs.config.js</strong> fichier spécifiant ou trouver les modules référencés par la directive import</li><li><strong>tsconfig.json</strong> fichier de configuration du transpiler Typescript</li><li><strong>tslint.json</strong> fichier de configuration du tslinter, outil d'analyse en temps réel du code Typescript</li><li><strong>package.json</strong> fichier de configuration de script shell, sert également à décrire le projet et l'ensemble des dépendances qui y sont associés.</li></ul></div>	<p class="pagination">27/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Serveur de développement Angular 2</h2>	<div class="page_content"><p>Angular 2 est un framework destiné à être utilisé sur un serveur de développement local, pour faciliter la mise en place de ce type de développement, il est possible de faire appel à un serveur léger dont le nom est lite-server. Ce serveur est livré et préconfiguré si vous utilisez ng-cli, il permet de:</p><ul class="page_list"><li>De relancer la compilation à chaque modification du code source</li><li>De redéployer le code le cas échéant</li><li>De relancer les tests unitaires ainsi que les tests end-to-end</li><li>De tester plus facilement la mise en place de nouvelles fonctionnalités</li></ul><p>Bien entendu ce serveur de développement ne pourra pas servir d'environnement final, ne serait-ce que pour des problématiques de sécurité et de performances. Pour voir le serveur en action il vous suffit de mettre en place un projet à l'aide de ng-cli et de taper la commande <strong>ng-serve</strong> au sein de l'invite de commande.</p></div>	<p class="pagination">28/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Tree Shaking</h2>	<div class="page_content"><p>Une application Angular 2 est principalement constituée de composants et des templates HTML qui y sont associés. Avant d'être rendue, ces derniers doivent être convertis en code Javascript éxécutable par le compilateur intégré à Angular, et à partir de ce moment là 2 solutions s'offrent à vous:</p><ul class="page_list"><li>Soit vous laissez le mode de compilation classique propre à la machine virtuelle Javascript opérer (J.I.T compiler), ce qui consiste en gros à faire en sorte que les composants et templates sont recompilés à l'éxécution.</li><li>Soit vous pré-compilez ce code en amont (AOT compilation) à l'aide des outils fournis par Angular, ce qui constitue un gain en performance et vous permet également de découvrir les erreurs autrement qu'à l'éxécution.</li></ul><p>Les avantages sont multiples à utiliser la compilation A.O.T, en production c'est le mode compilation à privilégier, lors du développement, cela reste à l'appréciation du développeur. Utiliser ce mode de compilation réclame cependant un surplus de configuration que vous pourrez trouver à l'adresse suivante: https://angular.io/guide/aot-compiler</p></div>	<p class="pagination">29/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Gestion des modules: Bonnes pratiques</h2>	<div class="page_content"><p>Un NgModule est une classe à laquelle on a ajouté le decorateur @NgModule, ce dernier prend en charge un objet décrivant des méta-données qui permettent à Angular de savoir comment compiler et démarrer le module. Au sein des méta-données sont également spécifiés les composants, directives, pipes, services etc ... Embarqués par le module et mis à disposition des autres modules.</p><p>Chaque Application Angular 2 dispose au moins d'un module, le module d'application, qu'il faut configurer et lancer afin de démarrer l'application. Il est recommandé, lorsque des composants et services doivent être partagés entre plusieurs modules, de regrouper ces applications dans un module partagé (SharedModule) que les autres spécifieront comme étant une dépendance</p><p>Les modules peuvent être pré-compilés à l'aide du compilateur ngc (A.O.T compilation) ou tout simplement compilés à l'utilisation (J.I.T compilation), ils peuvent être tous chargés au démarrage de l'application, ou à la demande par le Router d'Angular.</p><p class="legend">ng2_root_module.js</p><code><pre><span class="hljs-keyword">import</span> { NgModule }      <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { BrowserModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span>;
<span class="hljs-keyword">import</span> { DarkStarComponent }  <span class="hljs-keyword">from</span> <span class="hljs-string">'./darkstar.component'</span>;

@NgModule({
  <span class="hljs-attr">imports</span>:      [ BrowserModule ],
  <span class="hljs-attr">declarations</span>: [ DarkStarComponent ],
  <span class="hljs-attr">bootstrap</span>:    [ DarkStarComponent ]
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppModule</span> </span>{ }</pre></code></div>	<p class="pagination">30/89</p></div><!-- page --><!-- section --><div class="section">	<h2 class="section_title">Injection de dépendances & bonnes pratiques</h2></div><!-- section --><!-- page --><div class="page">	<h2 class="page_title">Principes de l'injection de dépendances</h2>	<div class="page_content"><p>Le principe de l'injection de dépendance est assez simple, dans le cadre d'un développement MVC classique, les fichiers declasses embarquent des références directes aux classes tierces qu'ils utilisent, ce qui le rend le développement lourd à maintenir et empêche le développeur de réutiliser facilement son code. On dit que l'on fait du "monolithic development",dans le sens ou les couches logicielles sont constituées souvent de gros blocs de code.</p><p>L'injection de dépendances quand à elle, permet de déléguer à un objet tiers, la création des objets dont nos modules vontavoir besoin. Cet objet est appelée l'injecteur de dépendance, il va donc se charger de créer les objets demandés etles envoyer aux objets qui en ont besoin. Ainsi ces derniers pourront utiliser des dépendances sans avoir besoin d'avoirune référence directe à ces dernières.</p><p>De plus, cela permet de tester différentes versions de l'application facilement, en effet, puisque les composants ne créentplus eux-mêmes les objets dont ils ont besoin ( souvent des classes gérant des échanges de données par le biais de services), il est possible de demander à l'injecteur de tester une version de l'application avec tel dépendance injectée, puisavec une autre, et ce, en changeant uniquement les élements de configuration.</p><p>Ce pattern s'intègre parfaitement dans le cadre d'une application développée avec des tests d'intégration continue. Parmi les méthodes utilitaires de l'objet angular, la méthode injector nous permet de créer un injecteur de dépendances.</p></div>	<p class="pagination">32/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Gestion des modules: Bonnes pratiques</h2>	<div class="page_content"><p>Un NgModule est une classe à laquelle on a ajouté le decorateur @NgModule, ce dernier prend en charge un objet décrivant des méta-données qui permettent à Angular de savoir comment compiler et démarrer le module. Au sein des méta-données sont également spécifiés les composants, directives, pipes, services etc ... Embarqués par le module et mis à disposition des autres modules.</p><p>Chaque Application Angular 2 dispose au moins d'un module, le module d'application, qu'il faut configurer et lancer afin de démarrer l'application. Il est recommandé, lorsque des composants et services doivent être partagés entre plusieurs modules, de regrouper ces applications dans un module partagé (SharedModule) que les autres spécifieront comme étant une dépendance</p><p>Les modules peuvent être pré-compilés à l'aide du compilateur ngc (A.O.T compilation) ou tout simplement compilés à l'utilisation (J.I.T compilation), ils peuvent être tous chargés au démarrage de l'application, ou à la demande par le Router d'Angular.</p><p class="legend">ng2_root_module.js</p><code><pre><span class="hljs-keyword">import</span> { NgModule }      <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { BrowserModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span>;
<span class="hljs-keyword">import</span> { DarkStarComponent }  <span class="hljs-keyword">from</span> <span class="hljs-string">'./darkstar.component'</span>;

@NgModule({
  <span class="hljs-attr">imports</span>:      [ BrowserModule ],
  <span class="hljs-attr">declarations</span>: [ DarkStarComponent ],
  <span class="hljs-attr">bootstrap</span>:    [ DarkStarComponent ]
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppModule</span> </span>{ }</pre></code></div>	<p class="pagination">33/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Module personnalisé: BookModule</h2>	<div class="page_content"><p>Le module ci-dessous embarque des fonctionnalités liés à un objet de type livre. Il met à disposition du développeur un objet BookComponent, ainsi qu'un service nous permettant de manipuler les données liées aux livres.</p><p class="legend">ng2_bookmodule.js</p><code><pre><span class="hljs-keyword">import</span> { NgModule }             <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> {BookComponent }         <span class="hljs-keyword">from</span> <span class="hljs-string">'./book.component'</span>;
<span class="hljs-keyword">import</span> {BookService}            <span class="hljs-keyword">from</span> <span class="hljs-string">'./book.service'</span>;

@NgModule({
  <span class="hljs-attr">declarations</span>:[BookComponent], 
  <span class="hljs-attr">providers</span>:[BookService]
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookModule</span> </span>{}
</pre></code><p class="legend">ng2_bookmodule_import.js</p><code><pre><span class="hljs-keyword">import</span> {NgModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> {BookModule} <span class="hljs-keyword">from</span> <span class="hljs-string">'./book.module'</span>;
<span class="hljs-keyword">import</span> { AppComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.component'</span>;

@NgModule({
  <span class="hljs-attr">declarations</span>: [AppComponent],
  <span class="hljs-attr">imports</span>: [BookModule],
  <span class="hljs-attr">providers</span>:[],
  <span class="hljs-attr">bootstrap</span>: [AppComponent]
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppModule</span> </span>{ }</pre></code></div>	<p class="pagination">34/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">RouterModule</h2>	<div class="page_content"><p>Angular 2 propose un système de <strong>routing</strong>, çàd qu'il met en relation ce que l'on appelle des urls profondes ( ou deeplinks ) avec des instances de composants et des templates qu'Angular va se charger de créer à la place du développeur.</p><p>Le RouterModule peut être importé plusieurs fois, tant que le router traite avec des ressources partagées et globales, nous ne pouvons avoir qu'une seule instance du router service active à la fois. C'est d'ailleurs pour cela qu'il existe 2 façons de créer le module: RouterModule.forRoot and RouterModule.forChild.</p><p>La méthode forRoot qui crée un module contenant les directives, les routes et le RouterService lui-même.</p><p>La méthode forChild fait exactement la même à l'exclusion du RouterService.</p><p class="legend">ng2_routermodule.js</p><code><pre>@NgModule({
  <span class="hljs-attr">imports</span>:      [ 
    BrowserModule, 
    FormsModule, 
    HttpModule,
    RouterModule.forRoot([{<span class="hljs-attr">path</span>:<span class="hljs-string">"home"</span>, <span class="hljs-attr">component</span>: AppComponent} ])
  ],
  <span class="hljs-attr">declarations</span>: [ AppComponent ],
  <span class="hljs-attr">bootstrap</span>:    [ AppComponent ], 
  <span class="hljs-attr">providers</span>:[]
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppModule</span> </span>{ }
</pre></code></div>	<p class="pagination">35/89</p></div><!-- page --><!-- section --><div class="section">	<h2 class="section_title">Définition de composants</h2></div><!-- section --><!-- page --><div class="page">	<h2 class="page_title">Comprendre les Web Components. (standard, concepts, shadow DOM, scoped CSS...).</h2>	<div class="page_content"><p>Lorsque l'on développe une application, plus on écrit de code, plus celui-ci a besoin d'être modulaire, réutilisable et encapsulé et pour cela, côté frond, les <strong>Web Components</strong> viennent à notre rescousse. Il s'agit avant tout d'une spécification du W3C en cours de rédaction mise en avant par les acteurs du Web (Les deux éditeurs de la spécification travaillent chez Google). Mais en vrai ça consiste en quoi ? En vrai, les Web Components c'est :</p><ul class="page_list"><li>Templates</li><li>Éléments customs</li><li>Shadow DOM</li><li>Encapsulation de style</li><li>Observers (pour le modèle ainsi que pour le DOM)</li><li>Variables CSS</li></ul><p>Pour en apprendre plus sur cette spécification, je vous invite à vous rendre à l'adresse suivante: https://developer.mozilla.org/fr/docs/Web/Web_Components. Il est important de noter que le système de composants d'Angular 2 respecte au mieux les spécifications des Web Components.</p></div>	<p class="pagination">37/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Cycle de vie dans l'application</h2>	<div class="page_content"><p>Les instances de Directives et Composants instances disposent d'un cycle de vie au sein d'Angular à mesure que le framework crée, met à jour, et détruit lesdites instances. Les dévelopeurs peuvent attraper et intervenir sur divers moments de ce cyle de vie en implémentant des méthodes d'interfaces que l'on appelle des <strong>Hooks</strong>.</p><p>L'ensemble des <strong>Hooks</strong> disponibles pour un composant est listé ci-dessous, pour savoir à quoi chacun de ces hook correspond, rendez-vous à l'adresse suivante: https://angular.io/guide/lifecycle-hooks </p><img src="data:image/png;base64,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" width="auto" height="300px" /></div>	<p class="pagination">38/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Angular Compiler : Change Detection</h2>	<div class="page_content"><p>Pour ceux qui ont connu Angular JS, l'une des expériences les plus douloureuses fût l'expérimentation de la boucle de rendu, ou plus exactement l'expérimentation de la lenteur et de la surconsommation de ressources de la boucle de rendu. En effet, en plus d'offrir une API un peu bancale, cette boucle de rendu avait pour mauvaise habitude de consommer un peu (trop) de ressources au niveau du CPU, aujourd'hui Angular 2 introduit un système différent, basé sur la librairie zone.js <strong>sans déficit en termes de fonctionnalités</strong>.</p><p>En vérité Angular 2 utilise sa propre version un peu remaniée de la librairie zone.js que l'on peut appeller NgZone, cette librairie a pour but premier de détecter les changements opérés côté Model et côté View afin de permettre le relancement d'une boucle de rendu et une synchronisation simplifiée des données entre le Model et la View.</p><p>Chaque fois qu'une action est effectuée par le développeur, comme le chargement d'une ressource externe par exemple à l'aide d'un mécanisme asynchrone, ou le fait de taper dans un champ texte par exemple, NgZone va détecter ces opérations et relancer un cycle de rendu / synchronisation.</p><p>Pour un complément d'information sur les dessous programmatiques de cette librairie NgZone, je vous invite à vous rendre à l'adresse suivante: https://auth0.com/blog/understanding-angular-2-change-detection/</p></div>	<p class="pagination">39/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Template Syntax</h2>	<div class="page_content"><p>Angular 2 intègre un système interne de templating, les templates sont des modèles HTML reliés à des données exposées via des instances de composants. Ce système de templating vient, comme tout bon système de templating, avec sa syntaxe propre.</p><p>On utilise la syntaxe suivante <strong>{{...}}</strong> pour faire référence à une propriété publique d'un composant, dans le but d'exposer sa valeur au sein de la boucle de rendu par le biais d'une <strong>interpolation</strong>. Cette syntaxe nous permet de lier les données dans un sens seulement, on parle de <strong>one-way databinding</strong></p><p>On a également accès à des Templates Statements, qui sont en fait des moyens de faire de la programmation évenementielle au sein des templates, et donc de répondre à des évenements utilisateurs.</p><p>Angular 2 nous donne également au data-binding bidirectionnel ou <strong>two-ways databinding</strong> à l'aide de la syntaxe [(...)] portant le nom de <strong>banana in the box</strong>.</p><p>Plus d'infos à l'adresse suivante: https://angular.io/guide/template-syntax#attribute-class-and-style-bindings</p></div>	<p class="pagination">40/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Le symbole *</h2>	<div class="page_content"><p>Pour les directives structurelles, le symbole * est utilisé, il s'agit de sucre syntaxique, çàd une facilité programmatique accéder à quelque chose d'un peu plus compliqué en arrière plan. Angular 2 utilise ce symbole et le décompose en 2 étapes.</p><p>Premièrement, dans le cas de la directive structurelle ( ou comportementale ) *ngIf, la directive va être traduite sous la forme d'un attribut de template: template='ngIf (...conditions...)'</p><p>Puis dans un second temps, cet attribut de template va ête traduit en élement <ng-template></ng-template> qui va encapsuler l'élement hôte de la directive.</p><p class="legend">ng2_asterisk.js</p><code><pre>&lt;div *ngIf="jedi"&gt;{{jedi.name}}&lt;&lt;/div&gt;
//....

&lt;div template="ngIf jedi"&gt;{{jedi.name}}&lt;/div&gt;

//.....

&lt;ng-template [ngIf]="hero"&gt;
  &lt;div&gt;{{hero.name}}&lt;/div&gt;
&lt;/ng-template&gt;
</pre></code></div>	<p class="pagination">41/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Les variables locales de template</h2>	<div class="page_content"><p>Angular 2 permet la création et l'utilisation de variables locales au sein des templates. Ces variables n'existent que le temps de leur utilisation ou le temps de vie complet du template. L'exemple le plus probant étant les variables que l'on déclare systématiquement lors de l'utilisation de la directive structurelle *ngFor. En effet l'on déclare systématiquement une variable temporaire chargée de stocker, à mesure que l'itération sur une liste évolue, la valeur de cette liste à un instant t.</p><p class="legend">ng2_local_templates_variables.js</p><code><pre><span class="hljs-comment">// ici la variable warrior a une durée de vie limitée, </span>
<span class="hljs-comment">// qui est celle de la directive structurelle *ngFor, </span>
<span class="hljs-comment">// en de dehors de l'élement hôte ( la div ), la variable warrior</span>
<span class="hljs-comment">// sera inaccessible</span>
&lt;div *ngFor=<span class="hljs-string">"let warrior of jedis"</span>&gt;{{warrior.name}}&lt;<span class="hljs-regexp">/div&gt;</span></pre></code></div>	<p class="pagination">42/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Les classes de composants</h2>	<div class="page_content"><p>Les classes de composants sont des classes affûblées du décorateur @Component, disponible de base au sein d'Angular 2. Ce décorateur permet au développeur de définir des métadonnées qui donneront des informations à Angular sur comment instancier et utiliser le composant, mais également sur les différentes classes qu'il peut utiliser en tant que fournisseur de services (providers), le sélecteur HTML auquel il répond (selector), et surtout son template ou le chemin vers celui-ci.</p><p class="legend">ng2_component_class.js</p><code><pre><span class="hljs-comment">// exemple d'une classe de composant JediComponent</span>
@Component(
    { 
        <span class="hljs-attr">selector</span>: <span class="hljs-string">'jedi'</span>, 
        <span class="hljs-attr">template</span>: <span class="hljs-string">'Hello Jedi {{rank}} !'</span> 
    }
)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JediComponent</span> </span>{
    rank: string = <span class="hljs-string">'Master'</span>;
}</pre></code></div>	<p class="pagination">43/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">EventEmitter</h2>	<div class="page_content"><p>Angular 2 propose la mise en place et la création d'évenements personnalisées, ainsi que leur diffusion à l'aide de la classe EventEmitter, utilisée surtout par les directives ( un composant est une directive jouissant d'un lien avec un template ) afin de gérer une programmation évenementielle customisée.</p><p class="legend">ng2_events.js</p><code><pre>@Component({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'jedi'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;button (click)="toggle()"&gt;Change Side Force&lt;/button&gt;`</span>})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JediComponent</span> </span>{

  isOnTheDarkSide: boolean = <span class="hljs-literal">true</span>;
  @Output() dark: EventEmitter&lt;any&gt; = <span class="hljs-keyword">new</span> EventEmitter();
  @Output() light: EventEmitter&lt;any&gt; = <span class="hljs-keyword">new</span> EventEmitter();
 
  toggle() {

    <span class="hljs-keyword">this</span>.isOnTheDarkSide = !<span class="hljs-keyword">this</span>.isOnTheDarkSide;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isOnTheDarkSide) {
      <span class="hljs-keyword">this</span>.open.emit(<span class="hljs-literal">null</span>);
    } 
    <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.close.emit(<span class="hljs-literal">null</span>);
    }
  }
}

<span class="hljs-comment">//....</span>

&lt;jedi (dark)=<span class="hljs-string">"darkHandler($event)"</span> (light)=<span class="hljs-string">"lightHandler"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">jedi</span>&gt;</span></span></pre></code></div>	<p class="pagination">44/89</p></div><!-- page --><!-- section --><div class="section">	<h2 class="section_title">Classifications des composants applicatifs</h2></div><!-- section --><!-- page --><div class="page">	<h2 class="page_title">RouterModule</h2>	<div class="page_content"><p>Angular 2 propose un système de <strong>routing</strong>, çàd qu'il met en relation ce que l'on appelle des urls profondes ( ou deeplinks ) avec des instances de composants et des templates qu'Angular va se charger de créer à la place du développeur.</p><p>Le RouterModule peut être importé plusieurs fois, tant que le router traite avec des ressources partagées et globales, nous ne pouvons avoir qu'une seule instance du router service active à la fois. C'est d'ailleurs pour cela qu'il existe 2 façons de créer le module: RouterModule.forRoot and RouterModule.forChild.</p><p>La méthode forRoot qui crée un module contenant les directives, les routes et le RouterService lui-même.</p><p>La méthode forChild fait exactement la même à l'exclusion du RouterService.</p><p class="legend">ng2_routermodule.js</p><code><pre>@NgModule({
  <span class="hljs-attr">imports</span>:      [ 
    BrowserModule, 
    FormsModule, 
    HttpModule,
    RouterModule.forRoot([{<span class="hljs-attr">path</span>:<span class="hljs-string">"home"</span>, <span class="hljs-attr">component</span>: AppComponent} ])
  ],
  <span class="hljs-attr">declarations</span>: [ AppComponent ],
  <span class="hljs-attr">bootstrap</span>:    [ AppComponent ], 
  <span class="hljs-attr">providers</span>:[]
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppModule</span> </span>{ }
</pre></code></div>	<p class="pagination">46/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Guards</h2>	<div class="page_content"><p>Angular 2 permet de protéger certaines routes à l'aide du système <strong>Guards</strong>. Protéger certaines routes est très utile par exemple dans le cas où on souhaite restreindre l'accès à certaines zones du site, où même demander une confirmation pour quitter une zone du site. Il existe 4 types de Guard différents:</p><ul class="page_list"><li><strong>CanActivate</strong> - Décide si une route peut être activée ou pas</li><li><strong>CanActivateChild</strong> - Décide si l'enfant d'une route peut être activée ou non</li><li><strong>CanDeactivate</strong> - Décide si une route peut être désactivée</li><li><strong>CanLoad</strong> - Décide si un module peut être chargé de manière 'fainénante' (à la demande uniquement)</li></ul><p>On peut retrouver quelques exemples d'implémentations des Guards à l'adresse suivante: https://angular.io/guide/router#guards.</p></div>	<p class="pagination">47/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Pipes</h2>	<div class="page_content"><p>Un Pipe prend des données en entrée et les transforment afin de délivrer le contenu de sortie que l'on souhaite obtenir. Il s'agit aussi d'un décorateur qui s'applique à une classe, cette classe permet de définir le code qui va gérer cette transformation de données et donc de construire des Pipes customisés. On peut enchaîner les Pipes les uns à la suite des autres, et Angular 2 procure un certains nombre de Pipes précodés.</p><p class="legend">ng2_pipes.js</p><code><pre><span class="hljs-comment">/*
* Fournit un Pipe qui prend en charge un tableau de données numériques 
* et retourne une moyenne de ces données numériques
*/</span>

<span class="hljs-keyword">import</span> { Pipe, PipeTransform } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

@Pipe({ <span class="hljs-attr">name</span>: <span class="hljs-string">'average'</span> })
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AveragePipe</span> <span class="hljs-title">implements</span> <span class="hljs-title">PipeTransform</span> </span>{
    transform(values: number[] ): number {
        <span class="hljs-keyword">let</span> avg:number = <span class="hljs-number">0</span>; 
        <span class="hljs-keyword">let</span> i:number = values.length;

        <span class="hljs-keyword">while</span>( --i &gt; <span class="hljs-number">-1</span> )
        {
            avg += values[i];
        }

        <span class="hljs-keyword">return</span> avg / values.length;
    }
}</pre></code></div>	<p class="pagination">48/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Principes de l'injection de dépendances</h2>	<div class="page_content"><p>Le principe de l'injection de dépendance est assez simple, dans le cadre d'un développement MVC classique, les fichiers declasses embarquent des références directes aux classes tierces qu'ils utilisent, ce qui le rend le développement lourd à maintenir et empêche le développeur de réutiliser facilement son code. On dit que l'on fait du "monolithic development",dans le sens ou les couches logicielles sont constituées souvent de gros blocs de code.</p><p>L'injection de dépendances quand à elle, permet de déléguer à un objet tiers, la création des objets dont nos modules vontavoir besoin. Cet objet est appelée l'injecteur de dépendance, il va donc se charger de créer les objets demandés etles envoyer aux objets qui en ont besoin. Ainsi ces derniers pourront utiliser des dépendances sans avoir besoin d'avoirune référence directe à ces dernières.</p><p>De plus, cela permet de tester différentes versions de l'application facilement, en effet, puisque les composants ne créentplus eux-mêmes les objets dont ils ont besoin ( souvent des classes gérant des échanges de données par le biais de services), il est possible de demander à l'injecteur de tester une version de l'application avec tel dépendance injectée, puisavec une autre, et ce, en changeant uniquement les élements de configuration.</p><p>Ce pattern s'intègre parfaitement dans le cadre d'une application développée avec des tests d'intégration continue. Parmi les méthodes utilitaires de l'objet angular, la méthode injector nous permet de créer un injecteur de dépendances.</p></div>	<p class="pagination">49/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Services Injectables</h2>	<div class="page_content"><p>Au fur et à mesure que les applications se développent, vous avez de plus en plus le besoin que les composants accèdent à des données externes à l'application. Dans la philosophie Angular, la couche qui s'occupe de l'accès aux données distantes est dédiée aux services.</p><p>Et il se trouve que les services sont des objets qui sont injectables en Angular, çàd que l'on peut spécifier à la plateforme que l'on souhaite, en tant que composant, obtenir une instance de tel ou tel service et celui-ci va nous la fournir. Bien entendu pour cela il faut utiliser un décorateur, le décorateur @Injectable.</p><p class="legend">ng2_services.js</p><code><pre><span class="hljs-keyword">import</span> { Injectable } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

@Injectable()
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeroService</span> </span>{}</pre></code></div>	<p class="pagination">50/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Configuration de l'injecteur de dépendances</h2>	<div class="page_content"><p>Le développeur n'a pas besoin de créer un injecteur de dépendances, Angular en fournit et en crée déjà un qui est accessible à travers toute l'application lors de la phase de démarre de l'application. On doit donc configurer l'injecteur de dépendances en spécifiant des <strong>providers</strong> qui crée les services dont l'application a besoin.</p><p>On peut soit définir des providers au sein d'un Module ou au sein de composants. Si vous spécifiez un service en tant que provider d'un module, tous les composants du même module se partageront la même instance du service, si vous le spécifiez uniquement en tant que provider d'un composant, alors il y aura une nouvelle instance à chaque fois.</p><p class="legend">ng2_providers.js</p><code><pre><span class="hljs-keyword">import</span> { Component }          <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { JediService }        <span class="hljs-keyword">from</span> <span class="hljs-string">'./jedi.service'</span>;

@Component({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'jedi'</span>,
  <span class="hljs-attr">providers</span>: [JediService],
  <span class="hljs-attr">template</span>: <span class="hljs-string">"Jedi master !"</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JediComponent</span> </span>{ 
    <span class="hljs-keyword">constructor</span>(p_service:JediService){
        
    }
}</pre></code></div>	<p class="pagination">51/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Host, ContentChild, ViewChild, ContentChildren et ViewChildren</h2>	<div class="page_content"><p>Les décorateurs @ContentChild, @ViewChild, @ContentChildren et @ViewChildren existent pour créer des liens entre l'élement hôte et les éléments qui sont imbriqués en son sein et qui font référence à des instances des composants.</p><p>Ces instances peuvent être imbriquées de deux façons, au sein du template du composant, ou elles peuvent être directement imbriquées au sein des données d'un composant hôte et ajoutées par projection de contenu sans avoir forcément besoin du template pour cela</p><p>Les ViewChildren font référence aux instances de composants crées à l'aide du template et les ContentChildren front eux référence aux données fournies par le composant lui-même par projection de contenu.</p><p>Les décorateurs nous servent donc à obtenir des références qui pointent vers les objets qui gèrent ces composants imbriqués. Pour plus de renseignement sur le sujet, vous pourrez trouver un excellent récapitulatif à l'adresse suivante: https://ng2.codecraft.tv/components/viewchildren-and-contentchildren/</p></div>	<p class="pagination">52/89</p></div><!-- page --><!-- section --><div class="section">	<h2 class="section_title">Gestion des formulaires & Reactive Forms</h2></div><!-- section --><!-- page --><div class="page">	<h2 class="page_title">FormControl, FormGroup, Template Driven Form & Data Driven Forms</h2>	<div class="page_content"><p>Angular 2 nous procure une multitude d'outils nous permettant de créer et gérer des formulaires assez facilement et ce, toujours de façon efficace. La notion de FormControl y est omniprésente, un FormControl est tout simplement un objet amené à gérer l'un des éléments du formulaire, à traquer ses changements de valeur, la validation des données qui y sont associés etc... </p><p>Un FormGroup est tout simplement qui regroupe un ensemble d'objets de type FormControl, il est donc tout à fait possible à l'aide de ces derniers de mutualiser et réutiliser des logiques de validation et d'analyse des données gérées par les FormControls.</p><p>Vous pouvez construire des formulaires en écrivant des templates, à l'aide de la syntaxe template angular et des directives de formulaires et de certaines techniques décrites au sein de la documentation, c'est ce que l'on appelle des <strong>templates driven forms</strong>.</p><p>Il est également possible de décrire un modèle de données, organisé de façon arborescente, de créer les contrôles qui y sont associés au sein des composants eux-mêmes plutôt que de déléguer ce travail au moteur de template, et enfin de tout fournir à Angular afin qu'il puisse concrétiser cela sous la forme d'une interface utilisateur exploitable.</p><p>L'un des avantages à utiliser un data driven form (Ou Reactive Forms), est que l'on peut introduire beaucoup plus facilement à l'aide de la programmation, des mécanises de tests sur les validations des formulaires par exemple. Pour plus de renseignements sur ces 2 types de Forms, ainsi que sur la gestion des formulaires en règle générale au sein d'Angular, rendez-vous aux adresses suivantes: https://angular.io/guide/reactive-forms et https://angular.io/guide/forms</p></div>	<p class="pagination">54/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Dynamic Input</h2>	<div class="page_content"><p>Il est possible de créer ses formulaires autrement que par le biais du template seul ( template driven form ), en effet les objets de type FormGroup, FormControl, et FormBuilder peuvent nous aider à créer des formulaires dynamiques, pilotés côté modèle.</p><p class="legend">ng2_dynamic_form.html</p><code><pre><span class="hljs-tag">&lt;<span class="hljs-name">form</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"myForm"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Prenom<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"firstname"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span> <span class="hljs-attr">formGroupName</span>=<span class="hljs-string">"details"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Age:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"age"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></pre></code><p class="legend">ng2_dynamic_form.ts</p><code><pre><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MyFormComponent <span class="hljs-keyword">implements</span> OnInit {

    myForm: FormGroup;

    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> formBuilder: FormBuilder</span>) { }

    ngOnInit() {

        <span class="hljs-keyword">let</span> data:<span class="hljs-built_in">Object</span> = { 
            firstname: <span class="hljs-string">''</span>,
            details: <span class="hljs-keyword">this</span>.formBuilder.group({ age: <span class="hljs-string">''</span>, })
        };

        <span class="hljs-keyword">this</span>.myForm = <span class="hljs-keyword">this</span>.formBuilder.group(data);

    }
}</pre></code></div>	<p class="pagination">55/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Validators</h2>	<div class="page_content"><p>Il est tout à fait possible d'ajouter à nos formulaires des validateurs (validators) et ce, directement au sein de notre modèle de données nous servant à le décrire:</p><p class="legend">ng2_forms_validators.ts</p><code><pre><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MyFormComponent <span class="hljs-keyword">implements</span> OnInit {
    
        myForm: FormGroup;
    
        <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> formBuilder: FormBuilder</span>) { }
    
        ngOnInit() {
    
            <span class="hljs-keyword">let</span> data:<span class="hljs-built_in">Object</span> = { 
                firstname: [<span class="hljs-string">''</span>, Validators.required],
                details: <span class="hljs-keyword">this</span>.formBuilder.group(
                    { 
                        age: [<span class="hljs-string">''</span>, Validators.required], 
                    }
                )
            };
    
            <span class="hljs-keyword">this</span>.myForm = <span class="hljs-keyword">this</span>.formBuilder.group(data);
    
        }
    }</pre></code></div>	<p class="pagination">56/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Validation asynchrone</h2>	<div class="page_content"><p>Par défaut les validateurs crées au sein du template sont toujours asynchrones, mais il est également possible de créer, ses propres validateurs asynchrones au sein du modèle. Nota bene: Angular éxécute les validateurs asynchrones après les validateurs synchrones.</p><p class="legend">ng2_async_validator.ts</p><code><pre><span class="hljs-keyword">import</span> { Directive, forwardRef } <span class="hljs-keyword">from</span> <span class="hljs-string">"@angular/core"</span>;
<span class="hljs-keyword">import</span> { NG_ASYNC_VALIDATORS, Validator, AbstractControl } <span class="hljs-keyword">from</span> <span class="hljs-string">"@angular/forms"</span>;
<span class="hljs-keyword">import</span> { Observable } <span class="hljs-keyword">from</span> <span class="hljs-string">"rxjs"</span>;
<span class="hljs-meta">@Directive</span>({
    selector: <span class="hljs-string">'[isAdult][ngModel],[isAdult][formControl]'</span>,
    providers: [
        { provide: NG_VALIDATORS, useExisting: forwardRef(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> IsAdultValidator), multi: <span class="hljs-literal">true</span> }
    ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> IsAdultValidator {

    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) { }

    validate(control: AbstractControl) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Observable(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> {
            <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">parseInt</span>(control.value &gt;= <span class="hljs-number">18</span>) ) {
                observer.next(  { asyncInvalid: <span class="hljs-literal">true</span> }  );
            } <span class="hljs-keyword">else</span> {
                observer.next(<span class="hljs-literal">null</span>);
            }
        });
    }
}</pre></code></div>	<p class="pagination">57/89</p></div><!-- page --><!-- section --><div class="section">	<h2 class="section_title">"Routing" et requête HTTP</h2></div><!-- section --><!-- page --><div class="page">	<h2 class="page_title">Echange de données avec le service Http</h2>	<div class="page_content"><p>Le module <strong>HttpModule</strong> n'est  pas un module central d'Angular, il s'agit plus d'un module optionnel proposant une solution pour la gestion des requêtes AJAX via le protocole HTTP. Il existe donc en tant que module séparé du coeur d'Angular et est contenu dans le paquetage @/http.</p><p>Votre application dépendra donc du service  Http, qui dépend lui-même d'autres petites choses, pour pouvoir l'utiliser, il vous suffit de spécifier le HttpModule en tant que dépendance du module princpal</p><p class="legend">ng2_http.js</p><code><pre>@NgModule({
  <span class="hljs-attr">imports</span>: [
    BrowserModule,
    FormsModule,
    HttpModule,
    AppRoutingModule
  ],
  <span class="hljs-attr">declarations</span>: [
    AppComponent,
    DashboardComponent,
    HeroDetailComponent,
    HeroesComponent,
  ],
  <span class="hljs-attr">providers</span>: [ HeroService ],
  <span class="hljs-attr">bootstrap</span>: [ AppComponent ]
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppModule</span> </span>{ }</pre></code></div>	<p class="pagination">59/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">RouterModule</h2>	<div class="page_content"><p>Angular 2 propose un système de <strong>routing</strong>, çàd qu'il met en relation ce que l'on appelle des urls profondes ( ou deeplinks ) avec des instances de composants et des templates qu'Angular va se charger de créer à la place du développeur.</p><p>Le RouterModule peut être importé plusieurs fois, tant que le router traite avec des ressources partagées et globales, nous ne pouvons avoir qu'une seule instance du router service active à la fois. C'est d'ailleurs pour cela qu'il existe 2 façons de créer le module: RouterModule.forRoot and RouterModule.forChild.</p><p>La méthode forRoot qui crée un module contenant les directives, les routes et le RouterService lui-même.</p><p>La méthode forChild fait exactement la même à l'exclusion du RouterService.</p><p class="legend">ng2_routermodule.js</p><code><pre>@NgModule({
  <span class="hljs-attr">imports</span>:      [ 
    BrowserModule, 
    FormsModule, 
    HttpModule,
    RouterModule.forRoot([{<span class="hljs-attr">path</span>:<span class="hljs-string">"home"</span>, <span class="hljs-attr">component</span>: AppComponent} ])
  ],
  <span class="hljs-attr">declarations</span>: [ AppComponent ],
  <span class="hljs-attr">bootstrap</span>:    [ AppComponent ], 
  <span class="hljs-attr">providers</span>:[]
})
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppModule</span> </span>{ }
</pre></code></div>	<p class="pagination">60/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Paramètres de route et router-outlet</h2>	<div class="page_content"><p>Afin de récupérer les paramètres des routes en Angular, il nous faut accéder à la route en cours à l'aide de l'objet ActivatedRoute et de l'objet RouteProvider. L'objet de type ActivatedRoute étant là pour symboliser la route active, et l'autre est censé donc nous fournir cette route.</p><p>Dans un second temps, une fois la route active identifiée et accessible, il nous pouvoir en récupérer les paramètres, c'est ici qu'Angular 2 nous propose d'utiliser alors les Observables, de sorte à ce que l'on puisse gérer proprement l'ensemble des mécanismes asynchrones d'Angular 2.</p><p>Une fois cette route entièrement décortiquées et mise en relation avec un composant, il nous faut déterminer ou va s'afficher le contenu associé au composant et à son template, c'est ici que la balise <router-outlet></router-outlet> vient à notre secours. Elle permet de spécifier ou devra se trouver le contenu à ajouter / modifier / remplacer.</p><p class="legend">ng2_routes_params.js</p><code><pre>
<span class="hljs-comment">// configuration d'une route au format REST indiquant une base fixe (details) </span>
<span class="hljs-comment">// et une partie variable à récupérer (:id)</span>
{<span class="hljs-attr">path</span>: <span class="hljs-string">'detail/:id'</span>, <span class="hljs-attr">component</span>: JediComponent}

<span class="hljs-comment">//.....</span>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JediComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span> </span>{
ngOnInit(): <span class="hljs-keyword">void</span> {
  <span class="hljs-keyword">this</span>.route.paramMap
    .switchMap(
        <span class="hljs-function">(<span class="hljs-params">params: ParamMap</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(params.get(<span class="hljs-string">'id'</span>))
    );
}</pre></code></div>	<p class="pagination">61/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Guards</h2>	<div class="page_content"><p>Angular 2 permet de protéger certaines routes à l'aide du système <strong>Guards</strong>. Protéger certaines routes est très utile par exemple dans le cas où on souhaite restreindre l'accès à certaines zones du site, où même demander une confirmation pour quitter une zone du site. Il existe 4 types de Guard différents:</p><ul class="page_list"><li><strong>CanActivate</strong> - Décide si une route peut être activée ou pas</li><li><strong>CanActivateChild</strong> - Décide si l'enfant d'une route peut être activée ou non</li><li><strong>CanDeactivate</strong> - Décide si une route peut être désactivée</li><li><strong>CanLoad</strong> - Décide si un module peut être chargé de manière 'fainénante' (à la demande uniquement)</li></ul><p>On peut retrouver quelques exemples d'implémentations des Guards à l'adresse suivante: https://angular.io/guide/router#guards.</p></div>	<p class="pagination">62/89</p></div><!-- page --><!-- section --><div class="section">	<h2 class="section_title">Observables & Reactive Programming</h2></div><!-- section --><!-- page --><div class="page">	<h2 class="page_title">Les Observables</h2>	<div class="page_content"><p>Un Observable est un producteur de données qui peut être observé. On le mettra sous observation avec la méthode <strong>subscribe</strong> et cette observation sera exécutée par un objet de type Observer. Les Observables se sont imposés dans le monde de la programmation réactive ( reactive programming ) par le biais de la librairie Reactive X, abrégé RxJs pour sa version Javascript. Un Observable peut également produire des données de façon asynchrone et il est possible de fusionner plusieurs Observables entre eux.</p><p>Il faut bien noter que les Observables sont souvent associés aux promesses, voire décrits comme des super-promesses, ce qui n'est pas tout à fait exact, un article entier a d'ailleurs été rédigé à l'attention des développeurs à l'adresse suivante: https://medium.com/@benlesh/learning-observable-by-building-observable-d5da57405d87 et explique un peu plus en détail ce que sont les Observables.</p><p class="legend">observables.js</p><code><pre>Rx.Observable.create(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">observer</span>) </span>{
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> observer.next(<span class="hljs-string">"valeur A"</span>), <span class="hljs-number">700</span>);
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> observer.next(<span class="hljs-string">"valeur B"</span>), <span class="hljs-number">400</span>);
})
 .subscribe(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(e));

 <span class="hljs-comment">// affiche "valeur A", puis "valeur B"  dans la console</span></pre></code></div>	<p class="pagination">64/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Créer des Observables</h2>	<div class="page_content"><p>Il est possible de créer des Observables en instanciant la classe Observable ou en utilisant des opérateurs dédiés (tels que of, from etc ... ).</p><p class="legend">ng2_observable_creation.js</p><code><pre><span class="hljs-comment">// Importe la classe Observable ainsi que </span>
<span class="hljs-comment">// l'intégralité des opérateurs</span>
<span class="hljs-keyword">import</span> {Observable} <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/RX'</span>;

<span class="hljs-comment">// on peut créer un Observable à partir d'un jeu de données à l'aide d'opérateurs</span>
<span class="hljs-keyword">let</span> obs = Observable.from([<span class="hljs-string">"Dark Vador"</span>, <span class="hljs-string">"Obiwan"</span>, <span class="hljs-string">"Maître Yoda"</span>]);
obs.subsribe(
    <span class="hljs-function">(<span class="hljs-params">character</span>) =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(character);
    }
);

<span class="hljs-comment">// ou alors à l'aide de l'opérateur new</span>
<span class="hljs-keyword">let</span> obs = <span class="hljs-keyword">new</span> Observable(
    <span class="hljs-function">(<span class="hljs-params">observer</span>) =&gt;</span> {
        observer.next(<span class="hljs-string">"Chewbacca"</span>);
        observer.next(<span class="hljs-string">"Han Solo"</span>);
        observer.next(<span class="hljs-string">"Princesse Leïa"</span>);
    }
);</pre></code></div>	<p class="pagination">65/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Cold Observables</h2>	<div class="page_content"><p>Un Cold Observable, est un Observable qui crée son propre producteur de données lors du déclenchement de la méthode |"subscribe". On utilise un Cold Observable de préférence uniquement lorsque la création répétée d'un producteur de données n'est pas dérangeante en termes de performances.</p><p>L'exemple ci-dessous nous donne l'exemple d'un Cold Observable qui crée son propre producteur de données à chaque subscribe.</p><p class="legend">ng2_cold_observables.js</p><code><pre><span class="hljs-comment">// ici, à chaque fois que l'on appelle la méthode subscribe de l'observable</span>
<span class="hljs-comment">// on crée une connexion au serveur websocket et on renvoit une function</span>
<span class="hljs-comment">// permettant de refermer cette connexion</span>

<span class="hljs-keyword">let</span> obs = <span class="hljs-keyword">new</span> Observable(

    <span class="hljs-function">(<span class="hljs-params">observer</span>) =&gt;</span> {
        <span class="hljs-keyword">let</span> socket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">'ws://someurl'</span>);
        socket.addEventListener(
            <span class="hljs-string">'message'</span>, 
            <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> observer.next(data)
        );

        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> socket.close();
    }
);</pre></code></div>	<p class="pagination">66/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Hot Observables</h2>	<div class="page_content"><p>Un Hot Observable, est un Observable dont le producteur de données est déclenché ou crée en dehors de la méthode "subscribe". ON utilisera de préférence un Hot Observable lorsqu'on souhaite écouter des données dont on peut considérer qu'elels peuvent être diffusées <strong>avant et après</strong> la souscription et la désinscription à l'Observable ( ex: MouseEvents ).</p><p>L'exemple ci-dessous nous donne l'exemple d'un Hot Observable dont le producteur de données est crée et activé en dehors de la méthode subscribe.</p><p class="legend">ng2_hot_observables.js</p><code><pre><span class="hljs-comment">// ici on crée un hot Observable, le producteur de données est crée</span>
<span class="hljs-comment">// en dehors du subscribe, en revanche, on évite de fournir une méthode </span>
<span class="hljs-comment">// de désinscription qui détruira le producteur de données car d'autres observables</span>
<span class="hljs-comment">// être en fin d'écouter le même producteur.</span>

<span class="hljs-keyword">let</span> socket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">'ws://someurl'</span>);

<span class="hljs-keyword">let</span> source = <span class="hljs-keyword">new</span> Observable(
    <span class="hljs-function">(<span class="hljs-params">observer</span>) =&gt;</span> {
        socket.addEventListener(
            <span class="hljs-string">'message'</span>,
            <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> observer.next(e)
        );
    }
);</pre></code></div>	<p class="pagination">67/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">ReplaySubject</h2>	<div class="page_content"><p>Un objet de type Subject est un objet qui est à la fois un Observer et un Observable. En tant qu'Observer, il peut souscrire à un Observable, et en tant qu'Observable, il peut produire des données et recevoir la souscription d'Observers.</p><p>Un objet de type ReplaySubject met en cache ses valeurs et les réemet à chacun de ses Observers, même les plus tardifs.</p><p class="legend">ng2_replaysubject.js</p><code><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">playSubject</span>(<span class="hljs-params">p_subject</span>) 
</span>{
    subject.onNext(<span class="hljs-string">"Jedi"</span>);

    subject.subscribe( 
        <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
            <span class="hljs-built_in">console</span>.log(data);
        }
    );

    subject.onNext(<span class="hljs-string">"Obiwan"</span>);
    subject.onNext(<span class="hljs-string">"Kenobi"</span>);
}
<span class="hljs-keyword">let</span> subject1 = <span class="hljs-keyword">new</span> Rx.Subject();
<span class="hljs-keyword">let</span> subject2 = <span class="hljs-keyword">new</span> Rx.ReplaySubject();

playSubject(subject1); <span class="hljs-comment">// affiche: Obiwan Kenobi</span>
playSubject(subject2); <span class="hljs-comment">// affiche: Jedi Obiwan Kenobi</span></pre></code></div>	<p class="pagination">68/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Les opérateurs les plus funs</h2>	<div class="page_content"><p>Il existe une multitude d'opérateurs livrés avec la librairie RxJS, ces derniers sont avant tout là pour nous faciliter la vie, en voici quelques-uns que l'on peut qualifier d'indispensables:</p><p class="legend">ng2_funniest_operators.js</p><code><pre><span class="hljs-comment">/*  
    interval: crée un observable qui va produire un entier qui s'incrémente
    toutes les x millisecondes.

    do: un opérateur n'ayant aucune influence sur le flux de données, utilisé
    dans le but de vérifier certaines informations ou d'effectuer une action parralèle

    map: même opérateur qu'en javascript es6, opère un traitement sur chacune 
    des valeurs retournées.

    take: permet de limiter la production de données, infinie par défaut, d'un 
    observable crée à l'aide d'"interval".
*/</span>
<span class="hljs-keyword">let</span> msg = <span class="hljs-string">"STAR WARS VII: The Force Awakens"</span>;
<span class="hljs-keyword">let</span> obs = Observable.interval(<span class="hljs-number">100</span>) 
                    .map( <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> msg[val])
                    .do( 
                        <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> {
                            <span class="hljs-built_in">document</span>.body.innerHTML += val;
                        } 
                    )
                    .take(msg.length);</pre></code></div>	<p class="pagination">69/89</p></div><!-- page --><!-- section --><div class="section">	<h2 class="section_title">Change detection: OnPush / Change detection total control</h2></div><!-- section --><!-- page --><div class="page">	<h2 class="page_title">Change Detection</h2>	<div class="page_content"><p>Angular se repose sur deux mécanismes pour détecter les changements de modèle de données et actualiser les vues associées aux divers composants qui composent le programme: </p><p>Le premier est un <strong>"Change Detector Tree"</strong>, un arbre symbolisant l'ensemble des objets attachés à chacun des composants et dont le rôle est de détecter l'ensemble des changements opérés sur le composant associé.</p><p>Le second est <strong>le principe d'immutabilité</strong>, à chaque fois que l'on souhaite changer une valeur d'une des propriétés d'un des composants, Angular fait en sorte de créer un nouvel objet, qui représente les données associées à ce composant. Cet objet va se voir affecter la nouvelle valeur, ainsi lorsque qu'Angular va lancer son cycle de détection des changements, en partant <strong>haut vers le bas</strong> de l'arbre, le <strong>Change Detector associé ne devra comparer que deux références d'objets, au lieu d'opérer une vérification profonde.</strong></p><p>Il est possible de court-circuiter le cycle de détection à un niveau précis, et de gérer soi-même la mécanique de rafraîchissement des données à l'aide de la stratégie <strong>onPush</strong>. Pour plus de détails sur le fonctionnement du cycle de détection et sur le contrôle total de celui-ci, vous pouvez vous rendre à l'adresse suivante: https://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html#reducing-the-number-of-checks</p></div>	<p class="pagination">71/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Booster le rendu avec OnPush</h2>	<div class="page_content"><p>Il est possible de faire d'opérer une stratégie de rendu différente pour un composant Angular. Prenons le cas du composant suivant: </p><p class="legend">ng2_boost_onpush.ts</p><code><pre><span class="hljs-meta">@Component</span>({
    template: <span class="hljs-string">`
      &lt;h2&gt;{{data.name}}&lt;/h2&gt;
      &lt;span&gt;{{data.surname}}&lt;/span&gt;
    `</span>,
    changeDetection: ChangeDetectionStrategy.OnPush
  })
  <span class="hljs-keyword">class</span> WarriorComponent {
    <span class="hljs-meta">@Input</span>() data;
  }</pre></code><p>Ce composant ne dispose d'aucune méthode interne lui permettant de changer ses propres valeurs, il attend qu'on les lui fournisse à l'aide du décorateur @Input(). En lui changeant sa stratégie et en la passant en mode OnPush, on fait en sorte que le rendu ne soit mis à jour que lorsque les données provenant de l'extérieur ( ou d'autres mécanismes déclenchant le rarfraîchissement ). Là l'exemple est simple, mais imaginez que ce composant dispose lui-même de sous composants etc ... Le gain de performances peut être énorme.</p></div>	<p class="pagination">72/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Contrôle total du rendu</h2>	<div class="page_content"><p>Admettons le cas ou l'on souhaite passer notre composant principal en strategie de rendu <strong>OnPush</strong>, aucun élement ne serait alors mis à jour à moins de le demander explicitement à Angular. Il est tout à fait possible d'avoir un contrôle total du rendu en le demandant directement à l'objet de type ChangeDetector associé à chacun des composants.</p><p class="legend">ng2_detection_full_control.ts</p><code><pre><span class="hljs-meta">@Component</span>({
    template: <span class="hljs-string">`
      &lt;h2&gt;{{data.name}}&lt;/h2&gt;
      &lt;span&gt;{{data.surname}}&lt;/span&gt;
    `</span>,
    changeDetection: ChangeDetectionStrategy.OnPush
  })
  <span class="hljs-keyword">class</span> WarriorComponent {
    
    <span class="hljs-meta">@Input</span>() data;

    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> cd: ChangeDetectorRef</span>) {}

    <span class="hljs-keyword">public</span> changeName()
    {
        <span class="hljs-keyword">this</span>.data.name = <span class="hljs-string">"Obiwan Kenobi"</span>;
        <span class="hljs-comment">// en appellant la méthode markForCheck, Angular va réévaluer les valeurs associées </span>
        <span class="hljs-comment">// au composant et relancer un rendu de ce dernier</span>
        <span class="hljs-keyword">this</span>.cd.markForCheck();
    }
  }</pre></code></div>	<p class="pagination">73/89</p></div><!-- page --><!-- section --><div class="section">	<h2 class="section_title">Transclusion & Content Projection</h2></div><!-- section --><!-- page --><div class="page">	<h2 class="page_title">Angular 2 et la Projection (Transclusion)</h2>	<div class="page_content"><p>Dans le composant ci-dessous, nous cherchons à injecter du contenu par un biais autre que le décorateur @Input(), ce dernier ne se prêtant pas facilement à l'injection de HTML ou d'un autre composant. Pour ce faire, nous allons faire appel au mécanisme de la <strong>Projection</strong>, anciennement nommé <strong>Transclusion</strong> en AngularJS.</p><p>La balise <ng-content></ng-content> à pour vocation d'accueillir du contenu défini à l'intérieur de l'élement HTML correspondant au sélecteur du composant.</p><p class="legend">ng2_transclusion.ts</p><code><pre><span class="hljs-keyword">import</span> { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'jedi'</span>,
  template: <span class="hljs-string">`
    &lt;div style="border: 1px solid blue; padding: 1rem;"&gt;
      &lt;h4&gt;Jedi Component&lt;/h4&gt;
      &lt;ng-content&gt;&lt;/ng-content&gt;
    &lt;/div&gt;`</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> JediComponent {}

<span class="hljs-comment">// creates the component from the host component ... </span>
</pre></code><p class="legend">ng2_transclusion.html</p><code><pre><span class="hljs-tag">&lt;<span class="hljs-name">jedi</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>I am the Jedi Master<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">jedi</span>&gt;</span></pre></code></div>	<p class="pagination">75/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Projection multiple</h2>	<div class="page_content"><p>On peut également utiliser la projection multiple en ciblant à l'aide de l'attribut select:</p><p class="legend">ng2_multiple_transclusion.ts</p><code><pre><span class="hljs-keyword">import</span> { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'jedi'</span>,
  template: <span class="hljs-string">`
    &lt;div&gt;
      &lt;ng-content select="jediname"&gt;&lt;/ng-content&gt;
      &lt;ng-content select="jedisurname"&gt;&lt;/ng-content&gt;
    &lt;/div&gt;`</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> JediComponent {}
</pre></code><p class="legend">ng2_multiple_transclusion.html</p><code><pre>&lt;jedi&gt;
    &lt;jediname&gt;
        &lt;h1&gt;Kenobi&lt;/h1&gt;
    &lt;/jediname&gt;
    &lt;jedisurname&gt;
        &lt;h2&gt;Obiwan&lt;/h2&gt;
    &lt;/jedisurname&gt;
&lt;/jedi&gt;</pre></code></div>	<p class="pagination">76/89</p></div><!-- page --><!-- section --><div class="section">	<h2 class="section_title">Tests unitaires, bonnes pratiques et outils</h2></div><!-- section --><!-- page --><div class="page">	<h2 class="page_title">Préparationde l'environnement de test</h2>	<div class="page_content"><p>Afin de pouvoir tester correctement notre application Angular 2, il nous faut créer un environnement propice aux tests, qui se composera de plusieurs couches:</p><ul class="page_list"><li>L'installation et la configuration de protractor end-to-end test runner (e2e)</li><li>L'installation et la configuration de Jasmine, framework de test unitaire Javascript</li><li>L'installation de Karma, test launcher qui va nous permettre de lancer la moulinette de tests unitaires Javascript sur l'ensemble des navigateurs désirés.</li><li>Et enfin l'écriture de tests à  proprement parler</li></ul><p>Ce n'est qu'en respectant l'ensemble de ces étapes que nous aurons un environnement de test valable.</p></div>	<p class="pagination">78/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Karma, Jasmine & Protractor</h2>	<div class="page_content"><p>Karma est un outil de terminal JavaScript qui permet le lancement de navigateurs web. Une fois le navigateur lancé, Karma y charge le code de l’application et exécute vos tests. Il est possible d’utiliser Karma afin de lancer votre application sur plusieurs navigateurs (Chrome, Safari, IE, PhantomJS, …). Cela vous permet de vérifier que votre application fonctionne bien partout! Lors de l’exécution de vos tests, les résultats sont affichés directement dans votre terminal. Pour plus d'informations rendez-vous sur le site de karma à l'adresse suivante: https://karma-runner.github.io/1.0/index.html</p><p>Jasmine est un framework de tests unitaires Javascript orienté comportement. Il ne dépend d'aucune librairie tierce et ne requiert même pas l'accès à l'API du DOM et il possède une syntaxe claire, évidente, qui permet d'écrire rapidement et simplement des tests unitaires. Pour plus d'informations, rendez-vous sur le site de Jasmine à l'adresse suivante: https://jasmine.github.io/</p><p>Protractor est un framework de test de bout en bout pour Angular, qui permet au développeur de tester son application comme un utilisateur lambda mais avec des tâches de tests automatisées. Pour plus d'informations rendez-vous sur le site de protractor à l'adresse suivante: http://www.protractortest.org/#/</p></div>	<p class="pagination">79/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Tester un composant Angular</h2>	<div class="page_content"><p>Un composant Angular est la première chose que tout développeur voudra tester en priorité. Ci-dessous le composant "BannerComponent" est un exemple simple de composant qui peut nous servir comme point de départ. Son rôle est d'afficher le titre de l'application dans une balise h1.</p><p class="legend">ng2_testing_component1.ts</p><code><pre><span class="hljs-keyword">import</span> { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-banner'</span>,
  template: <span class="hljs-string">'&lt;h1&gt;{{title}}&lt;/h1&gt;'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> BannerComponent {
  title = <span class="hljs-string">'STAR WARS: THE RETURN OF THE JEDI'</span>;
}
</pre></code></div>	<p class="pagination">80/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Test un composant Angular</h2>	<div class="page_content"><p class="legend">ng2_testing_component1.spec.ts</p><code><pre>
<span class="hljs-keyword">import</span> { ComponentFixture, TestBed } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core/testing'</span>;
<span class="hljs-keyword">import</span> { By }                        <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span>;
<span class="hljs-keyword">import</span> { DebugElement }              <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { BannerComponent }           <span class="hljs-keyword">from</span> <span class="hljs-string">'./banner-inline.component'</span>;

describe(<span class="hljs-string">'BannerComponent (inline template)'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {

  <span class="hljs-keyword">let</span> comp:    BannerComponent;
  <span class="hljs-keyword">let</span> fixture: ComponentFixture&lt;BannerComponent&gt;;
  <span class="hljs-keyword">let</span> de:      DebugElement;
  <span class="hljs-keyword">let</span> el:      HTMLElement;

  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    TestBed.configureTestingModule({
      declarations: [ BannerComponent ], <span class="hljs-comment">// declare the test component</span>
    });

    fixture = TestBed.createComponent(BannerComponent);

    comp = fixture.componentInstance; <span class="hljs-comment">// BannerComponent test instance</span>

    <span class="hljs-comment">// query for the title &lt;h1&gt; by CSS element selector</span>
    de = fixture.debugElement.query(By.css(<span class="hljs-string">'h1'</span>));
    el = de.nativeElement;
  });
});</pre></code></div>	<p class="pagination">81/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Tester un composant Angular</h2>	<div class="page_content"><p><strong>TestBed</strong> nous sert à créer un module de test Angular que l'on configure par la suite à l'aide de la méthode <strong>configureTestingModule</strong> afin de produire un environnement pour la classe à tester.</p><p>La méthode <strong>configureTestingModule</strong> prend en paramètre des metadonnées, au même titre que n'importe quel autre module.</p><p>Une fois le module de test configuré, on fait appel à la méthode TestBed.createComponent qui crée donc une instance de BannerComponent et qui retourne un objet de type <strong>ComponentFixture</strong>.</p><p>Un objet de type ComponentFixture est en fait un <strong>gestionnaire</strong> qui nous permet d'accéder à l'instance de <strong>BannerComponent</strong> ainsi qu'à un objet de type <strong>DebugElement</strong>, ce dernier est un gestionnaire du DOM associé à ce composant.</p><p>A l'aide de la méthode <strong>query</strong> de l'objet de type <strong>DebugElement</strong> il est possible d'accéder aux élements du DOM généré à l'aide du template du composant.</p></div>	<p class="pagination">82/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Tester un service Angular</h2>	<div class="page_content"><p>Voyons voir comment tester un service retournant des valeurs asynchrones, ci-dessous, le service WarriorService est censé retourner une Promesse. On voudrait vérifier qu'il y ait au moins 2 guerriers de retournés.</p><p class="legend">ng2_service_testing.ts</p><code><pre><span class="hljs-keyword">import</span> { Injectable } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> WarriorService {

    <span class="hljs-keyword">public</span> getAll(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">Object</span>[]&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(
            [
                { name: <span class="hljs-string">"kenobi"</span>, surname: <span class="hljs-string">"obiwan"</span> },
                { name: <span class="hljs-string">"vador"</span>, surname: <span class="hljs-string">"dark"</span> }
            ]
        );
    }
}
</pre></code></div>	<p class="pagination">83/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Tester un service Angular</h2>	<div class="page_content"><p class="legend">ng2_service_testing.spec.ts</p><code><pre><span class="hljs-keyword">import</span> { TestBed, inject } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core/testing'</span>;

<span class="hljs-keyword">import</span> { WarriorService } <span class="hljs-keyword">from</span> <span class="hljs-string">'./warrior.service'</span>;

describe(<span class="hljs-string">'WarriorService'</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        TestBed.configureTestingModule({
            providers: [WarriorService]
        });
    });

    it(<span class="hljs-string">'should return at least 2 warriors'</span>,
        inject([WarriorService],
            <span class="hljs-function">(<span class="hljs-params">service: WarriorService</span>) =&gt;</span> {
                service.getAll().then(
                    <span class="hljs-function">(<span class="hljs-params">tab: <span class="hljs-built_in">Object</span>[]</span>) =&gt;</span> {
                        expect(tab.length).toBeGreaterThan(<span class="hljs-number">1</span>);
                    }
                );
            }
        )
    );
});
</pre></code></div>	<p class="pagination">84/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Spies & Mocks</h2>	<div class="page_content"><p>Si l'on veut tester un composant faisant appel à un ou plusieurs services, lesquels vont chercher des données de manière asynchrones sur un serveur quelconque, il est recommandé de tout faire pour que les appels en question ne soient pas réalisés.</p><p>En effet, le serveur cible peut être innateignable depuis l'environnement de test, ou tout simplement éteint, ce qui ferait échouer toute la chaîne de tests, il est donc courant:</p><p>Soit de fournir un faux service émulant les comportements du service injecté au composant.</p><p>Soit de court-circuiter les méthodes du service renvoyant des données asynchrones à l'aide de <strong>spies et de mocks.</strong></p><p>Un spy comme son nom l'indique, est une fonction qui a pour but d'espionner l'appel à une autre fonction. Une fois la fonction espionnée appelée, l'espion prend le relais et opère un traitement différent, émulant ainsi le comportement souhaité.</p><p>Un mock consiste tout simplement en une série de données ressemblant trait pour trait aux données que le serveur nous aurait renvoyés. Le but est de disposer d'un jeu de données conforme aux attentes du test et ce, sans faire appel à un environnement extérieur.</p></div>	<p class="pagination">85/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Spies & Mocks</h2>	<div class="page_content"><p class="legend">ng2_spies_mocks.ts</p><code><pre>beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  TestBed.configureTestingModule({
     declarations: [ WarriorComponent ],
     providers:    [ WarriorService ],
  });

  fixture = TestBed.createComponent(WarriorComponent);
  comp    = fixture.componentInstance;
  service = fixture.debugElement.injector.get(WarriorService);

  spy = spyOn(service, <span class="hljs-string">'getAll'</span>)
        .and.returnValue(<span class="hljs-built_in">Promise</span>.resolve(
            [{<span class="hljs-string">"name"</span>: <span class="hljs-string">"skywalker"</span>, <span class="hljs-string">"surname"</span>: <span class="hljs-string">"anakin"</span>}]
        ));

  <span class="hljs-comment">// WarriorComponent.refresh callas WarriorService.getAll()</span>
  <span class="hljs-comment">// and fills his public "warriors" property</span>
  comp.refresh();

  expect(comp.warriors.length).toBeGreatThan(<span class="hljs-number">0</span>);
});</pre></code></div>	<p class="pagination">86/89</p></div><!-- page --><!-- section --><div class="section">	<h2 class="section_title">Webpack</h2></div><!-- section --><!-- page --><div class="page">	<h2 class="page_title">Webpack: présentation é & configuration</h2>	<div class="page_content"><p>Webpack est ce que l'on peut appeler un empaqueteur de module. Un paquet est un fichier Javascript qui incorpore des contenus ayant un rapport les uns avec les autres et qui doivent être délivrés au client en une seule requête.</p><p>Un paquet peut être composé de fichiers Javascript, CSS, HTML, images etc... Pour empaqueter ces différents types de fichiers, Webpack traverse toute votre application à la recherche de références directes à des fichiers, qu'il charge par le biais de "loaders" (des unités logicielles prenant en charge un type de fichier spécifique), ou à des classes.</p><p>Il est bien entendu possible de configurer Webpack à l'aide du fichier <strong>webpack.config.js</strong>.</p></div>	<p class="pagination">88/89</p></div><!-- page --><!-- page --><div class="page">	<h2 class="page_title">Les loaders indispensables</h2>	<div class="page_content"><ul class="page_list"><li><strong>awesome-typescript-loader</strong>: Un loader permettant de prendre en charge les fichiers Typescript.</li><li><strong>css-loader</strong>: Un loader permettant de prendre en charge les fichiers css.</li><li><strong>html-loader</strong>: Un loader permettant de prendre en charge les fichiers HTML</li><li><strong>raw-loader</strong>: Un loader permettant de prendre en charge des données binaires brutes, images, vidéos etc...</li><li><strong>style-loader</strong>: Un loader permettant de prendre en charge des styles css embarqués.</li><li><strong>file-loader</strong>: Un loader permettant de prendre en charge des fichiers de type texte.</li></ul></div>	<p class="pagination">89/89</p></div><!-- page --></div></body></html>